/*
Algorithm Evaluation: Comparing which algorithm is good in particular situations.
1) Analytic Evaluation:
    The algorithm and some system workload (assuming some processes and their CPU Burst) are used to produce a 
    formula or number which gives the performance of the algorithm for that workload.
    
    Do this for all the algorithms which you want to compare.
    WorkLoad can be:
        => Deterministic Modeling
            Predetermined workload (as we are doing till now) and performance of each algorithm for
            that workload. Use of Gantt Charts.
                Simple and Fast
                Exact numbers for comparison
                Requires exact input
                Performance figures may not be true in general
        => Queuing Modeling
            Computer system viewed as a network of queues and servers.
                Queues: Ready queue, I/O queue, Event queue
                Servers: which serve to processes in queues. | CPU's. I/O device controllers etc.
            Input: Arrival and service rates
                rates are not actually some numbers but actually numbers after some distributions.
            Output: CPU utilization, average queue length, average wait time.
            Basic Calculation of Queueing Modeling
                Little's Formula:
                    n = λ*W
                    where;
                    n = average queue length
                    λ = average arrival rate
                    W  = average wait time in queue
                We can calculate Average Queue Length of algorithms and then compare using this formula.
            Complicated Mathematics
            Distributions can be of:
                 Poisson, uniform, exponential, etc 
                 We use these for calculation of the arrival and departure rates 
                 Difficult work with.
                 Assumptions may not accurate ==> That we use Poisson but processes come in Exponential.
                 Approximation of the real system

2) Simulation
    Programming model for the computer system.

    Simulation can work with workload:    
    WorkLoad generated by assuming some distributions and a random number generator,
    or by collecting data from the actual system.


    Get Data of actual system and store them in trace tape.
    Give to simulation (programming model for computer system) of different algorithms and get performances of algos.

    Expensive: hours of programming and execution time
    Maybe erroneous because of the assumptions about distributions.



3) Implementation ==> Apply Algos directly on system and allow users to use them, and then get performance.
    Best
    Most Expensive Because we have to change algo in kernel again and again and also  for checking by users.
        Good option due to Open source kernels such as linux
*/


/*
Process Synchronization:

Concurrent access to shared data may result in data inconsistency.

Maintaining data consistency requires mechanism to ensure that cooperating
processes access shared data sequentially.
*/


/*
Bounded Buffer Problem: 
We discussed its solution. But at that solution we have to leave 1 space in buffer.
But now we are also have solution in which we are using full space of buffer.

Solution:
#define BUFFER_SIZE 10
tyoedef struct {
    ...
} item;

item buffer[BUFFER_SIZE];
int in = 0; out = 0;
int counter = 0;


We are maintaining a counter for producer and consumer both.
in is for producer which will increase when produce from buffer.
out is for consumer which will increase when consume from buffer.


Producer code:

item nextProduced;
while (1){
    nextProduced= getItem();
    while(counter == BUFFER_SIZE);
    buffer[in] = nextProduced;
    in = (in + 1) % BUFFER_SIZE; // for increasing in variable with cricular buffer.
    counter++;
}


Consumer Process:


item nextConsumed;
while (1){
    nextProduced= getItem();
    while(counter == 0);
    nextConsumed = buffer[out];
    out = (out + 1) % BUFFER_SIZE; // for increasing out variable with cricular buffer.
    counter--;
}
*/


/*
Bounded Buffer Problem in assembly:
PRODUCER:
In assembly actually, counter is place in register and then register is incremented and then again place in counter.
CONSUMER:
In assembly actually, counter is place in register and then register is decremented and then again place in counter.

But what producer and consumer reach at this line of code at the same time. Means Producer increment the value in register but before placing it in counter
it find interrupt and shifted to consumer. Now consumer will decrement the counter value which is not actual value now. actual value was in register.
So this is problem that the process which ended in the last. it can be producer and consumer but in both case output is going to wrong.

Race Condition: The situation where several processes access and manipulate shared data concurrently, the
final value of the data depends on which process finishes last. 

So above condition is race condition.
*/



/*
Critical Section: A piece of code in a cooperating processes in which
the process may update shared data (variable, file, database).

Critical Section is actually the code which creates problem, so we 
have to serialize execution of critical sections in cooperating processes.

Critical Section Problem: Making serialize solution for critical solution is problem.



Solution of critical solution:
1) Software based solution
2) Hardware based solution ==> Use CPU instructions to solve.
3) OS based solution

*/


/*
Structure of Solution

do {
    entry section
    critical section
    exit section
        reminder section
}while (1);
*/