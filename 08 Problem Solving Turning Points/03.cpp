/*
Turning point was on the logic in if condition. I also have to put = there also. So always check if condition.
*/

/*
 i use loops for handling counter and then get answer.
 But instead i can use directly subtraction.
 z-x gives number of places far from the mouse
 z-y gives number of places far from the mouse
 compare and give answer. 
 But maybe sometimes x or y greater than z then for just use abs(z-x) and abs(z-y). This gives -1 to 1 means positive with same magnitude.
*/

/*
Understand question and then make proper logic and then write code.
*/


/*
I use nested loop and array of english characters to get number of actual array.
But he calculates it by using 'a' - 97 // 97 is the value of lower case stating point in ascii. so it will give same number(index) as we 
required to get number of actual array.

https://youtu.be/oHIwfH4-vdU // Check here sol
 */


 /*
 Here i have given 1 integer as parameter.
 It will test it by different test cases.
 So I simply have to consider that the given n value is the value from which i have to get result.
 */


/*
turning is that if we take number mod with some number to whom we want to check result would be whole or not.
IF AFter mod its answer become 0 then it will be whole else not,

Reverse number formula:
while (number > 0) {
        result1 = result1 * 10 + number % 10;
        number /= 10;
    }

    abs give positive number
    ceil give high of particular point number
    floor give low of particular point number


*/